#!/usr/bin/env python

import sys
import os
import platform


# where the script is located, which is the project repo root dir
CORE_DIR = os.path.dirname(os.path.realpath(__file__))

# install venv to here
V_DIR = "venv"


def get_platform():
    """ Detects the running platform, and if linux checks if a raspberry pi
    """

    plat = platform.system().lower()

    if plat == 'linux' and platform.linux_distribution()[0].lower() == 'debian':
        try:
            with open('/proc/cpuinfo') as f:
                for line in f:
                    line = line.strip().split()
                    if len(line) < 2:
                        continue

                    if line[0] == 'Hardware' and line[-1] in ['BCM2708', 'BCM2709']:
                        return 'raspberry-pi'
        except:
            pass

    return plat


def get_file_path(f):
    """ Returns the full file path of a file, inside the main project repo
    """

    return "%s/%s" % (CORE_DIR, f)


def print_color(s, color="yellow"):
    """Print with a color! Uses tput to output escape codes for colors
    """

    colors = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
    color = color.lower()

    if color in colors:
        color_num = colors.index(color)
        os.system("tput setaf %d 2>/dev/null" % color_num)
        print s
        os.system("tput sgr0 2>/dev/null")
    else:
        print s


def run_commands(commands):
    """ Run a list of commands and print out what commands are being run when doing so
    """

    for com in commands:
        print_color("\nRunning: %s \n" % com, color="cyan")
        if os.system(com) != 0:
            print_color("\n Non-zero error code running: %s\nStopping install." % com, color="red")
            sys.exit()


def create_venv():
    """ Create a virtual env if it doesn't exist already
    """

    venv_real_dir = get_file_path(V_DIR)

    if not os.path.isdir(venv_real_dir):
        print_color("\nCreating virtual env in %s..." % V_DIR)
        run_commands(["virtualenv %s" % venv_real_dir])
    else:
        print_color("\nVirtual env in %s already exists" % V_DIR)


def start_venv():
    """ Activate the virtual env, so we can install things with pip too it,
    or run files and tests with it enabled
    """

    venv_real_dir = get_file_path(V_DIR)

    # exit the virtual env isn't created
    if not os.path.isdir(venv_real_dir):
        print_color("\nVirual env does not exist in %s. Have you ran install?" % V_DIR)
        sys.exit(1)

    # Activate the virtual env
    print_color("\nActivating virtual env...")

    # exec the virtual envs activate python file
    activate_file = venv_real_dir + "/bin/activate_this.py"
    try:
        execfile(activate_file, dict(__file__=activate_file))
    except Exception as e:
        print_color(e.message, color="red")
        print_color("\nError activating virtualenv", color="red")
        sys.exit(1)


def install(args):
    """ Install things
    """

    is_ras_pi = False

    # if argument is passed and it's valid, set is_ras_pi if it's --pi
    if len(args) > 0 and args[0] in ['--pi', '--dev']:
        is_ras_pi = (args[0] == '--pi')

    # Otherwise autodetect
    else:
        platform = get_platform()
        if platform not in ['linux', 'raspberry-pi']:
            print_color("\nInstalls on non linux systems are not supported yet! :(", color="red")
            sys.exit()

        is_ras_pi = (platform == 'raspberry-pi')

    if is_ras_pi:
        print_color("\nInstalling components for Raspberry Pi")
    else:
        print_color("\nInstalling components for dev system")

    # Check if we have root access
    if os.geteuid() != 0:
        print_color("\nYou don't have permissions to install items. Exiting", color="red")
        sys.exit()

    install_items = []

    # install basic things
    with open(get_file_path("install/apt-get.txt")) as f:
        basic_install_items = f.read().split("\n")[:-1]
        install_items.extend(basic_install_items)

    # install ras pi things
    if is_ras_pi:
        with open(get_file_path("install/apt-get-hw.txt")) as f:
            pi_install_items = f.read().split("\n")[:-1]
            install_items.extend(pi_install_items)

    install_command = [
        "apt-get install -y " + " ".join(install_items),
        "pip install --upgrade pip",
        "pip install --upgrade virtualenv",
    ]

    run_commands(install_command)

    print_color("\nInstalling and activating virtual env")
    create_venv()
    start_venv()

    commands_to_run = []

    commands_to_run.append(
        "pip install -r %s" % get_file_path("install/requirements.txt")
    )

    if is_ras_pi:
        commands_to_run.append(
            "pip install -r %s" % get_file_path("install/requirements-hw.txt")
        )

    run_commands(commands_to_run)

    if os.environ['SUDO_USER']:
        print_color("\nRunning with sudo, so chown the virtual env dir to the sudo user.")
        command = "chown -R {user}:{user} {dir}".format(user=os.environ['SUDO_USER'],
                                                        dir=get_file_path(V_DIR))
        run_commands([command])

    if is_ras_pi:
        i2c_enabled = os.system("i2cdetect -y 1 > /dev/null 2>&1")
        if i2c_enabled != 0:
            print_color("\ni2c is not enabled. Will run raspi-config to enable the device.")
            print_color("Enable in Advanced Options > i2c")
            print_color("\nEnter n to skip, or any other key to continue and launch raspi-config [Y/n]:")

            if raw_input().lower() != 'n':
                run_commands(["raspi-config"])
                print_color("\nYou may have to reboot to fully enable i2c")

    print_color("\nFinished Install!\n", color="green")


def run(args):
    """ Run the rov code. Currently supports running the flask app
    or the rov main loop by itself. Will also set debug vars with --debug.
    Uses the install virtual env as well.
    """

    if '--debug' in args:
        os.environ['FLASK_DEBUG'] = "1"
        os.environ['ROV_DEBUG'] = "1"
    else:
        os.environ['FLASK_DEBUG'] = ""
        os.environ['ROV_DEBUG'] = ""

    start_venv()

    if '--rov' in args:
        print_color("Running ROV main loop:\n")
        os.system("python %s" % get_file_path("rov/rov.py"))
    else:
        print_color("Running full ROV stack:\n")
        os.environ["FLASK_APP"] = "%s" % get_file_path("application.py")
        os.system("flask run --host=0.0.0.0") # bind flask app to 0.0.0.0

    # unset debug vars
    os.environ['FLASK_DEBUG'] = ""
    os.environ['ROV_DEBUG'] = ""


def shell(args):
    """ Create a shell with the virtual env variables set
    """

    print_color("Entering virtual env shell")

    debug = ('--debug' in args)

    commands = [
        'export VIRTUAL_ENV="%s"' % get_file_path(V_DIR), # venv root dir
        'export PATH="$VIRTUAL_ENV/bin:$PATH"', # add venv/bin to path
        'unset PYTHON_HOME', # unset so doesn't conflict with new path
        'export FLASK_APP="%s"' % get_file_path("application.py"), # For running flask app
        'export FLASK_DEBUG="%s"' % ("1" if debug else ""), # enable flask debug if --debug
        'export ROV_DEBUG="%s"' % ("1" if debug else ""), # enable rov debug if --debug
        'exec "${@:-$SHELL}"' # exec the users shell, with these variables set
    ]

    # Concat all the commands with ; and run as one command
    os.system("; ".join(commands))

    print_color("Exiting virtual env shell")


def test(args):
    """ Run testing framework
    """

    # Use the virtual env
    start_venv()

    test_all = (len(args) == 0)

    # hold list of failed tests
    failed = []

    if test_all or '--pep8' in args:
        print_color("Running pep8 test:\n")
        pep8_command = "pep8 --max-line-length=110 --ignore=E261"

        # Keep track of if any of these commands failed
        pep8_failed = False
        pep8_failed = os.system("%s %s" % (pep8_command, get_file_path("application.py"))) or pep8_failed
        pep8_failed = os.system("%s %s" % (pep8_command, get_file_path("rov/*/*.py"))) or pep8_failed
        pep8_failed = os.system("%s %s" % (pep8_command, get_file_path("scotty"))) or pep8_failed

        if pep8_failed:
            failed.append("pep8 conformity")

    # Print out list of failed tests, and exit with non-zero value if failed
    if len(failed) > 0:
        print_color("\nDetected %d failed test(s):" % len(failed), color="red")
        for failure in failed:
            print_color("- %s" % failure, color="red")

        sys.exit(1)


def usage(args):
    """ Prints the help and usage information
    """

    print "scotty install [--pi, --dev]"
    print "   Installs required files. Autodetects install type"
    print "   --pi:    Install as if this is a Pi"
    print "   --dev:   Install as if this is a dev machine"
    print ""
    print "scotty run [--rov] [--debug]"
    print "   Runs the full ROV stack"
    print "   --rov:   Just test the ROV main loop"
    print "   --debug: Set FLASK_DEBUG and ROV_DEBUG"
    print ""
    print "scotty shell [--debug]"
    print "   Runs a new shell, with the activated venv. Exit to leave venv"
    print "   --debug: Set FLASK_DEBUG and ROV_DEBUG"
    print ""
    print "scotty test [--pep8]"
    print "   Runs the full testing framework"
    print "   --pep8:  Run pep8 test"
    print ""
    print "scotty [-h] [--help]"
    print "   Display this help information"


def main():
    """ List of available commands. The first arugment is checked against
    these and is mapped to a function to execute. If a command is passed that
    isn't here, then exit
    """

    availabe_commands = {
        "install": install,
        "run": run,
        "shell": shell,
        "test": test,
        "-h": usage,
        "--help": usage,
    }

    # No command present
    if len(sys.argv) < 2:
        usage([])
        sys.exit(1)

    command = sys.argv[1]

    if command not in availabe_commands:
        print_color("'%s' is not an available command\n" % command, color="red")
        usage([])
        sys.exit(1)

    # execute the method for the command
    availabe_commands[command](sys.argv[2:])


if __name__ == '__main__':
    main()
